## 解题思路
 
**迭代+递归**
+ 为了方便在head之前设立一个哑结点dummy，令dummy.next = head
+ 定义双指针start和end，start指向长度为k的待反转部分的前一个节点，end指向长度为k的待反转部分的后一个节点。也就是start和end中间部分才是需要反转的部分，start和end类似于哨兵节点。
+ 用count记录已遍历的链表长度，当count是k的整数倍时，代表start和end中间部分需要反转。
+ 返回dummy.next








## 代码

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        if head is None or k < 2:
            return head
        dummy = ListNode()
        dummy.next = head
        start = dummy
        end = head
        count = 0
        while end:
            count += 1
            if count % k == 0:
                start = self.reverse(start, end.next)
                end = start.next
            else:
                end = end.next
        return dummy.next

    def reverse(self, start, end):
        pre, cur = start, start.next
        first = cur
        while cur != end:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        start.next = pre
        first.next = cur
        return first
```



