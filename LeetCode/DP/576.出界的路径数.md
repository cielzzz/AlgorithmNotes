## 解题思路
 
dp[i][j][k]表示移动了i步以后，在当前位置（j,k）一共有多少种出界的路径数 
在构建dp的时候，反过来，原本dp[i][j][k]是按照：移动次数，行，列，那么构建的时候 是先 列方向*n



## 代码


```
class Solution:
    def findPaths(self, m:int, n:int, maxMove:int, startRow:int, startColumn:int ) -> int:
        MOD = 10**9 + 7
        res = 0
        dp = [[[0] * n for _ in range(m)] for _ in range(maxMove + 1)] #列 行 移动次数
        dp[0][startRow][startColumn] = 1 #当移动次数为0，且位置在初始行列时，初始状态为1
        for i in range(maxMove):
            for j in range(m):
                for k in range(n):
                    if dp[i][j][k] > 0:
                        for j1, k1 in [(j - 1, k), (j + 1, k), (j, k - 1), (j, k + 1)]:
                            if 0 <= j1 < m and 0 <= k1 < n:
                                dp[i + 1][j1][k1] = (dp[i +1][j1][k1] + dp[i][j][k]) % MOD
                            else:
                                res = (res + dp[i][j][k]) % MOD #出界，将dp[i][j][k]值加到res中 
        return res 
```



